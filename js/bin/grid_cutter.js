// Generated by CoffeeScript 1.3.3
(function() {
  var GridCutter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  GridCutter = (function(_super) {

    __extends(GridCutter, _super);

    function GridCutter() {
      this.nx = 1;
      this.ny = 1;
    }

    GridCutter.prototype.cut = function(image) {
      var h, pieces, pt00, pt01, pt10, pt11, shape, w, x, y, _i, _j, _ref, _ref1;
      GridCutter.__super__.cut.call(this, image);
      this.count = this.nx * this.ny;
      w = Math.round(this.width / this.nx);
      h = Math.round(this.height / this.ny);
      pieces = new Array();
      this.parity = 1;
      for (y = _i = 0, _ref = this.ny; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        this.parity *= -1;
        for (x = _j = 0, _ref1 = this.nx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          pt00 = new Point(x * w, y * h);
          pt01 = new Point(x * w, y * h + h);
          pt10 = new Point(x * w + w, y * h);
          pt11 = new Point(x * w + w, y * h + h);
          shape = new Shape();
          shape.graphics.beginBitmapFill(image);
          this.parity *= -1;
          this.draw_curve(shape.graphics, this.connect_curves([this.create_curve(pt00, pt01, this.parity), this.create_curve(pt01, pt11, -this.parity), this.create_curve(pt11, pt10, this.parity), this.create_curve(pt10, pt00, -this.parity)]));
          shape.boundary = [x * w, y * h, w, h];
          pieces.push(shape);
        }
      }
      return pieces;
    };

    GridCutter.prototype.draw_curve = function(g, points) {
      var i, pt, _i, _len, _ref, _results, _step;
      g.moveTo(points[0].x, points[0].y);
      _ref = points.slice(1);
      _results = [];
      for (i = _i = 0, _len = _ref.length, _step = 3; _i < _len; i = _i += _step) {
        pt = _ref[i];
        _results.push(g.bezierCurveTo(points[i + 1].x, points[i + 1].y, points[i + 2].x, points[i + 2].y, points[i + 3].x, points[i + 3].y));
      }
      return _results;
    };

    GridCutter.prototype.connect_curves = function(curves) {
      var points, pt, pts, _i, _j, _len, _len1, _ref;
      points = [];
      points.push(curves[0][0]);
      for (_i = 0, _len = curves.length; _i < _len; _i++) {
        pts = curves[_i];
        _ref = pts.slice(1);
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          pt = _ref[_j];
          points.push(pt);
        }
      }
      return points;
    };

    GridCutter.prototype.create_curve = function(pt0, pt1, parity) {
      var mtx, points, v1, v2;
      if (parity == null) {
        parity = 1;
      }
      points = [];
      points.push(pt0);
      v1 = pt1.subtract(pt0).scale(0.5);
      mtx = new Matrix2D();
      mtx.rotate(parity * Math.PI * 2 / 3);
      v2 = v1.apply(mtx);
      points.push(pt0.add(v1.scale(0.2)));
      points.push(pt0.add(v1));
      points.push(pt0.add(v1).add(v2.scale(0.5)));
      points.push(pt0.add(v1).add(v2));
      points.push(pt0.add(v1.scale(2)).add(v2));
      points.push(pt0.add(v1.scale(1.5)).add(v2.scale(0.5)));
      points.push(pt0.add(v1));
      points.push(pt0.add(v1.scale(1.8)));
      points.push(pt1);
      return points;
    };

    return GridCutter;

  })(Cutter);

  this.GridCutter = GridCutter;

}).call(this);
