// Generated by CoffeeScript 1.3.3
(function() {
  var GridCutter,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  GridCutter = (function(_super) {

    __extends(GridCutter, _super);

    function GridCutter() {
      GridCutter.__super__.constructor.apply(this, arguments);
      this.nx = 1;
      this.ny = 1;
    }

    GridCutter.prototype.cut = function() {
      var h, pcs, pieces, w, x, y, _i, _j, _ref, _ref1;
      this.count = this.nx * this.ny;
      w = Math.round(this.width / this.nx);
      h = Math.round(this.height / this.ny);
      this.linear_measure = Math.sqrt(w * w + h * h);
      pcs = this.create_pieces();
      this.create_points(pcs);
      this.create_curves(pcs);
      pieces = new Array();
      for (y = _i = 0, _ref = this.ny; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.nx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          pieces.push(pcs[y][x]);
        }
      }
      return pieces;
    };

    GridCutter.prototype.create_pieces = function() {
      var he, p, pcs, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
      pcs = [];
      for (y = _i = 0, _ref = this.ny; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        pcs.push([]);
        for (x = _j = 0, _ref1 = this.nx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          p = new Piece();
          he = HalfEdge.createLoop(4);
          p.setEdge(he);
          pcs[y].push(p);
        }
      }
      for (y = _k = 0, _ref2 = this.ny; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; y = 0 <= _ref2 ? ++_k : --_k) {
        for (x = _l = 0, _ref3 = this.nx; 0 <= _ref3 ? _l < _ref3 : _l > _ref3; x = 0 <= _ref3 ? ++_l : --_l) {
          if (x < this.nx - 1) {
            pcs[y][x].edge.next.next.setMate(pcs[y][x + 1].edge);
          }
          if (y > 0) {
            pcs[y][x].edge.next.next.next.setMate(pcs[y - 1][x].edge.next);
          }
          if (x > 0) {
            pcs[y][x].edge.setMate(pcs[y][x - 1].edge.next.next);
          }
          if (y < this.ny - 1) {
            pcs[y][x].edge.next.setMate(pcs[y + 1][x].edge.next.next.next);
          }
        }
      }
      return pcs;
    };

    GridCutter.prototype.create_points = function(pcs) {
      var h, pos, vec, w, x, y, _i, _j, _ref, _ref1;
      w = Math.round(this.width / this.nx);
      h = Math.round(this.height / this.ny);
      for (y = _i = 0, _ref = this.ny; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.nx; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          vec = new Point(w, h).scale(this.fluctuation * 0.5 * (Math.random() * 2 - 1));
          if (x === 0 || x === this.nx) {
            vec.x = 0;
          }
          if (y === 0 || y === this.ny) {
            vec.y = 0;
          }
          pos = new Point(x * w, y * h).add(vec);
          if (x === 0 && y === 0) {
            pcs[y][x].edge.setPoint(pos);
          } else if (x === 0) {
            pcs[y - 1][x].edge.next.setPoint(pos);
          } else if (y === 0) {
            pcs[y][x - 1].edge.next.next.next.setPoint(pos);
          } else {
            pcs[y - 1][x - 1].edge.next.next.setPoint(pos);
          }
        }
      }
    };

    GridCutter.prototype.create_curves = function(pcs) {
      var he, p, parity, x, y, _i, _ref, _results;
      parity = 1;
      _results = [];
      for (y = _i = 0, _ref = this.ny; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
        parity *= -1;
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (x = _j = 0, _ref1 = this.nx; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            parity *= -1;
            _results1.push((function() {
              var _k, _len, _ref2, _results2;
              _ref2 = pcs[y][x].edge.getLoopEdges();
              _results2 = [];
              for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
                he = _ref2[_k];
                parity *= -1;
                p = Math.random() < this.irregularity ? parity : -parity;
                if (he.curve == null) {
                  _results2.push(he.setCurve(this.create_curve(he, p)));
                } else {
                  _results2.push(void 0);
                }
              }
              return _results2;
            }).call(this));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    return GridCutter;

  })(Cutter);

  this.GridCutter = GridCutter;

}).call(this);
