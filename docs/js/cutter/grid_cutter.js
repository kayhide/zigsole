// Generated by CoffeeScript 1.12.7
(function() {
  var GridCutter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  GridCutter = (function(superClass) {
    extend(GridCutter, superClass);

    function GridCutter() {
      GridCutter.__super__.constructor.apply(this, arguments);
      this.nx = 1;
      this.ny = 1;
    }

    GridCutter.prototype.cut = function() {
      var h, i, j, pcs, pieces, ref, ref1, w, x, y;
      this.count = this.nx * this.ny;
      w = Math.round(this.width / this.nx);
      h = Math.round(this.height / this.ny);
      this.linear_measure = Math.sqrt(w * w + h * h);
      pcs = this.create_pieces();
      this.create_points(pcs);
      this.create_curves(pcs);
      pieces = new Array();
      for (y = i = 0, ref = this.ny; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
        for (x = j = 0, ref1 = this.nx; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
          pieces.push(pcs[y][x]);
        }
      }
      return pieces;
    };

    GridCutter.prototype.create_pieces = function() {
      var i, j, k, l, lp, p, pcs, ref, ref1, ref2, ref3, x, y;
      pcs = [];
      for (y = i = 0, ref = this.ny; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
        pcs.push([]);
        for (x = j = 0, ref1 = this.nx; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
          p = new Piece();
          lp = Loop.create(4);
          p.addLoop(lp);
          pcs[y].push(p);
        }
      }
      for (y = k = 0, ref2 = this.ny; 0 <= ref2 ? k < ref2 : k > ref2; y = 0 <= ref2 ? ++k : --k) {
        for (x = l = 0, ref3 = this.nx; 0 <= ref3 ? l < ref3 : l > ref3; x = 0 <= ref3 ? ++l : --l) {
          if (x < this.nx - 1) {
            pcs[y][x].loops[0].edge.next.next.setMate(pcs[y][x + 1].loops[0].edge);
          }
          if (y > 0) {
            pcs[y][x].loops[0].edge.next.next.next.setMate(pcs[y - 1][x].loops[0].edge.next);
          }
          if (x > 0) {
            pcs[y][x].loops[0].edge.setMate(pcs[y][x - 1].loops[0].edge.next.next);
          }
          if (y < this.ny - 1) {
            pcs[y][x].loops[0].edge.next.setMate(pcs[y + 1][x].loops[0].edge.next.next.next);
          }
        }
      }
      return pcs;
    };

    GridCutter.prototype.create_points = function(pcs) {
      var h, i, j, pos, ref, ref1, vec, w, x, y;
      w = Math.round(this.width / this.nx);
      h = Math.round(this.height / this.ny);
      for (y = i = 0, ref = this.ny; 0 <= ref ? i <= ref : i >= ref; y = 0 <= ref ? ++i : --i) {
        for (x = j = 0, ref1 = this.nx; 0 <= ref1 ? j <= ref1 : j >= ref1; x = 0 <= ref1 ? ++j : --j) {
          vec = new Point(w, h).scale(this.fluctuation * 0.5 * (Math.random() * 2 - 1));
          if (x === 0 || x === this.nx) {
            vec.x = 0;
          }
          if (y === 0 || y === this.ny) {
            vec.y = 0;
          }
          pos = new Point(x * w, y * h).add(vec);
          if (x === 0 && y === 0) {
            pcs[y][x].loops[0].edge.setPoint(pos);
          } else if (x === 0) {
            pcs[y - 1][x].loops[0].edge.next.setPoint(pos);
          } else if (y === 0) {
            pcs[y][x - 1].loops[0].edge.next.next.next.setPoint(pos);
          } else {
            pcs[y - 1][x - 1].loops[0].edge.next.next.setPoint(pos);
          }
        }
      }
    };

    GridCutter.prototype.create_curves = function(pcs) {
      var he, i, j, k, len, p, parity, ref, ref1, ref2, x, y;
      parity = 1;
      for (y = i = 0, ref = this.ny; 0 <= ref ? i < ref : i > ref; y = 0 <= ref ? ++i : --i) {
        parity *= -1;
        for (x = j = 0, ref1 = this.nx; 0 <= ref1 ? j < ref1 : j > ref1; x = 0 <= ref1 ? ++j : --j) {
          parity *= -1;
          ref2 = pcs[y][x].loops[0].getEdges();
          for (k = 0, len = ref2.length; k < len; k++) {
            he = ref2[k];
            parity *= -1;
            p = Math.random() < this.irregularity ? parity : -parity;
            if (he.curve == null) {
              he.setCurve(this.create_curve(he, p));
            }
          }
        }
      }
    };

    return GridCutter;

  })(Cutter);

  this.GridCutter = GridCutter;

}).call(this);
