// Generated by CoffeeScript 1.12.7
(function() {
  var DoubleCanvasController;

  DoubleCanvasController = (function() {
    function DoubleCanvasController(puzzle) {
      this.puzzle = puzzle;
      this.colors = {
        shadow: "#AFF"
      };
    }

    DoubleCanvasController.prototype.attach = function() {
      var active_canvas;
      active_canvas = document.createElement('canvas');
      active_canvas.id = "active";
      $(this.puzzle.stage.canvas).after(active_canvas);
      $(active_canvas).css('position', 'absolute').hide().draggable({
        cursor: 'move',
        scroll: false
      });
      this.active_stage = new Stage(active_canvas);
      $(this.puzzle.stage.canvas).on('mousewheel', (function(_this) {
        return function(e) {
          var p, ref;
          e = e.originalEvent;
          if (_this.captured == null) {
            p = (ref = _this.puzzle.stage.getObjectUnderPoint(e.clientX, e.clientY)) != null ? ref.piece : void 0;
            if (p != null) {
              _this.capture(p, _this.puzzle.container.globalToLocal(e.clientX, e.clientY));
            }
          }
          if (_this.captured == null) {
            if (e.wheelDelta > 0) {
              _this.zoom(e.x, e.y, 1.2);
            } else {
              _this.zoom(e.x, e.y, 1 / 1.2);
            }
          }
        };
      })(this));
      $(this.puzzle.stage.canvas).on('mousedown', (function(_this) {
        return function(e) {
          var p, pt, ref;
          pt = new Point(e.offsetX, e.offsetY);
          p = (ref = _this.puzzle.stage.getObjectUnderPoint(pt.x, pt.y)) != null ? ref.piece : void 0;
          if (p != null) {
            _this.capture(p, pt.to(_this.puzzle.container), e);
            return;
          }
          _this.dragStage(e);
        };
      })(this));
      return Command.onPost.push((function(_this) {
        return function(cmd) {
          var p, ref, ref1, ref2, ref3;
          if (cmd instanceof TransformCommand) {
            if (((ref = _this.captured) != null ? ref.piece : void 0) === cmd.piece) {
              if (cmd instanceof RotateCommand) {
                _this.putToActivelayer(cmd.piece);
              }
            } else {
              p = cmd.piece;
              ref1 = p.position(), p.shape.x = ref1.x, p.shape.y = ref1.y;
              p.shape.rotation = p.rotation();
              _this.puzzle.invalidate();
            }
          }
          if (cmd instanceof MergeCommand) {
            if (((ref2 = _this.captured) != null ? ref2.piece : void 0) === cmd.piece || ((ref3 = _this.captured) != null ? ref3.piece : void 0) === cmd.mergee) {
              _this.release();
            }
            cmd.mergee.shape.remove();
            _this.puzzle.invalidate();
          }
        };
      })(this));
    };

    DoubleCanvasController.prototype.putToActivelayer = function(p) {
      var boundary, pt0, pt1, ref;
      boundary = p.getBoundary().inflate(10);
      pt0 = this.puzzle.container.localToWindow(boundary.x, boundary.y);
      pt1 = this.puzzle.container.localToWindow(boundary.x + boundary.width, boundary.y + boundary.height);
      this.active_stage.copyTransform(this.puzzle.container);
      this.active_stage.x = 0;
      this.active_stage.y = 0;
      this.active_stage.canvas.width = pt1.x - pt0.x;
      this.active_stage.canvas.height = pt1.y - pt0.y;
      $(this.active_stage.canvas).css('left', pt0.x).css('top', pt0.y).width(this.active_stage.canvas.width).height(this.active_stage.canvas.height).show();
      ref = p.position().from(this.puzzle.container).to(this.active_stage), p.shape.x = ref.x, p.shape.y = ref.y;
      p.shape.rotation = p.rotation();
      this.active_stage.addChild(p.shape);
      return this.updateActive();
    };

    DoubleCanvasController.prototype.updateActive = function() {
      if (this.active_stage.children.length > 0) {
        $(this.active_stage.canvas).show();
      } else {
        $(this.active_stage.canvas).hide();
      }
      return this.active_stage.update();
    };

    DoubleCanvasController.prototype.capture = function(p, point, event) {
      var blur;
      if (!p.isAlive()) {
        return;
      }
      if (this.captured != null) {
        return Command.commit();
      } else {
        window.console.log("captured[" + p.id + "] ( " + point.x + ", " + point.y + " )");
        this.captured = {
          piece: p,
          point: point
        };
        if (event != null) {
          this.captured.dragging = true;
        }
        blur = 8;
        p.shape.shadow = new Shadow(this.colors.shadow, 0, 0, blur);
        this.putToActivelayer(p);
        this.puzzle.invalidate();
        $(this.active_stage.canvas).on({
          drag: (function(_this) {
            return function(e, ui) {
              var pt, vec;
              pt = new Point(e.clientX, e.clientY).toWindow().to(_this.active_stage).to(_this.puzzle.container);
              vec = pt.subtract(_this.captured.point);
              _this.captured.point = pt;
              new TranslateCommand(_this.captured.piece, vec).post();
            };
          })(this),
          dragstart: (function(_this) {
            return function(e, ui) {
              _this.captured.dragging = true;
              _this.captured.point = new Point(e.clientX, e.clientY).toWindow().to(_this.active_stage).to(_this.puzzle.container);
            };
          })(this),
          mouseup: (function(_this) {
            return function(e, ui) {
              _this.captured.dragging = null;
              Command.commit();
              _this.puzzle.tryMerge(_this.captured.piece);
            };
          })(this),
          mousewheel: (function(_this) {
            return function(e) {
              var piece, ref;
              e = e.originalEvent;
              if (_this.captured != null) {
                ref = _this.captured, piece = ref.piece, point = ref.point;
                new RotateCommand(piece, point, -e.wheelDelta / 10).post();
              }
            };
          })(this)
        });
        $(window).on({
          mousemove: (function(_this) {
            return function(e) {
              var pt, ref;
              if (((ref = _this.captured) != null ? ref.dragging : void 0) == null) {
                _this.captured.point = new Point(e.clientX, e.clientY).toWindow().to(_this.active_stage).to(_this.puzzle.container);
                pt = _this.captured.point.to(_this.captured.piece.shape);
                if (!_this.captured.piece.shape.hitTest(pt.x, pt.y)) {
                  _this.release();
                }
              }
            };
          })(this)
        });
        if ((event != null ? event.type : void 0) === 'mousedown') {
          return $(this.active_stage.canvas).trigger(event);
        }
      }
    };

    DoubleCanvasController.prototype.release = function() {
      var p, ref;
      if (this.captured != null) {
        window.console.log("released[" + this.captured.piece.id + "]");
        p = this.captured.piece;
        p.shape.shadow = null;
        if (p.isAlive()) {
          ref = p.position(), p.shape.x = ref.x, p.shape.y = ref.y;
          p.shape.rotation = p.rotation();
          this.puzzle.container.addChild(p.shape);
        }
        this.captured = null;
        $(this.active_stage.canvas).off('drag dragstart mouseup mousewheel');
        $(window).off('mousemove');
        Command.commit();
        this.puzzle.stage.update();
        return this.updateActive();
      }
    };

    DoubleCanvasController.prototype.zoom = function(x, y, scale) {
      return this.puzzle.zoom(x, y, scale);
    };

    DoubleCanvasController.prototype.dragStage = function(event) {
      var h, last_point, pt0, pt1, ref, w;
      ref = [window.screen.width, window.screen.height], w = ref[0], h = ref[1];
      pt0 = new Point(-w / 2, -h / 2).fromWindow().to(this.puzzle.wrapper);
      pt1 = new Point(w * 3 / 2, h * 3 / 2).fromWindow().to(this.puzzle.wrapper);
      this.puzzle.wrapper.cache(pt0.x, pt0.y, pt1.x - pt0.x, pt1.y - pt0.y);
      last_point = new Point(event.clientX, event.clientY);
      return $(window).on({
        mousemove: (function(_this) {
          return function(e, ui) {
            var pt;
            pt = new Point(e.clientX, e.clientY);
            _this.puzzle.wrapper.x += pt.x - last_point.x;
            _this.puzzle.wrapper.y += pt.y - last_point.y;
            last_point = pt;
            _this.puzzle.invalidate();
          };
        })(this),
        mouseup: (function(_this) {
          return function(e, ui) {
            _this.puzzle.wrapper.uncache();
            _this.puzzle.invalidate();
            $(window).off('mousemove mouseup');
          };
        })(this)
      });
    };

    return DoubleCanvasController;

  })();

  this.DoubleCanvasController = DoubleCanvasController;

}).call(this);
