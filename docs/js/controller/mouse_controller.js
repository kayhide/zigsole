// Generated by CoffeeScript 1.12.7
(function() {
  var MouseController;

  MouseController = (function() {
    function MouseController(puzzle) {
      this.puzzle = puzzle;
      this.colors = {
        shadow: "#AFF"
      };
    }

    MouseController.prototype.attach = function() {
      this.activelayer = new Container();
      this.puzzle.stage.addChild(this.activelayer);
      $(this.puzzle.stage.canvas).on('mousewheel', (function(_this) {
        return function(e) {
          var p, ref;
          e = e.originalEvent;
          if (_this.captured == null) {
            p = (ref = _this.puzzle.stage.getObjectUnderPoint(e.clientX, e.clientY)) != null ? ref.piece : void 0;
            if (p != null) {
              _this.capture(p, _this.puzzle.container.globalToLocal(e.clientX, e.clientY));
            }
          }
          if (_this.captured == null) {
            if (e.wheelDelta > 0) {
              _this.zoom(e.x, e.y, 1.2);
            } else {
              _this.zoom(e.x, e.y, 1 / 1.2);
            }
          }
        };
      })(this));
      $(this.puzzle.stage.canvas).on('mousedown', (function(_this) {
        return function(e) {
          var p, pt, ref;
          if (_this.captured != null) {
            return;
          }
          pt = new Point(e.offsetX, e.offsetY);
          p = (ref = _this.puzzle.stage.getObjectUnderPoint(pt.x, pt.y)) != null ? ref.piece : void 0;
          if (p != null) {
            _this.capture(p, pt.to(_this.puzzle.container), e);
            return;
          }
          _this.dragStage(e);
        };
      })(this));
      return Command.onPost.push((function(_this) {
        return function(cmd) {
          var p, ref, ref1, ref2;
          if (cmd instanceof TransformCommand) {
            p = cmd.piece;
            ref = p.position(), p.shape.x = ref.x, p.shape.y = ref.y;
            p.shape.rotation = p.rotation();
            _this.puzzle.invalidate();
          }
          if (cmd instanceof MergeCommand) {
            if (((ref1 = _this.captured) != null ? ref1.piece : void 0) === cmd.piece || ((ref2 = _this.captured) != null ? ref2.piece : void 0) === cmd.mergee) {
              _this.release();
            }
            cmd.mergee.shape.remove();
            _this.puzzle.invalidate();
          }
        };
      })(this));
    };

    MouseController.prototype.putToActivelayer = function(p) {
      this.activelayer.copyTransform(this.puzzle.container);
      return this.activelayer.addChild(p.shape);
    };

    MouseController.prototype.capture = function(p, point, event) {
      var blur;
      if (p.isAlive() && (this.captured == null)) {
        window.console.log("captured[" + p.id + "] ( " + (point.x.toFixed(2)) + ", " + (point.y.toFixed(2)) + " )");
        this.captured = {
          piece: p,
          point: point
        };
        if ((event != null ? event.type : void 0) === 'mousedown') {
          this.captured.dragging = true;
        }
        blur = 8;
        p.shape.shadow = new Shadow(this.colors.shadow, 0, 0, blur);
        this.putToActivelayer(p);
        this.cacheStage();
        this.puzzle.invalidate();
        return $(window).on({
          mousedown: (function(_this) {
            return function(e) {
              var pt;
              if (_this.captured != null) {
                pt = new Point(e.clientX, e.clientY).fromWindow().to(_this.puzzle.container);
                _this.captured.point = pt;
                _this.captured.dragging = true;
              }
            };
          })(this),
          mouseup: (function(_this) {
            return function(e) {
              if (_this.captured != null) {
                _this.captured.dragging = null;
                _this.puzzle.tryMerge(_this.captured.piece);
              }
            };
          })(this),
          mousewheel: (function(_this) {
            return function(e) {
              var piece, ref;
              e = e.originalEvent;
              if (_this.captured != null) {
                ref = _this.captured, piece = ref.piece, point = ref.point;
                new RotateCommand(piece, point, -e.wheelDelta / 10).post();
              }
            };
          })(this),
          mousemove: (function(_this) {
            return function(e) {
              var pt, pt0, ref, vec;
              if (((ref = _this.captured) != null ? ref.dragging : void 0) != null) {
                pt0 = _this.captured.point;
                _this.captured.point = new Point(e.clientX, e.clientY).fromWindow().to(_this.puzzle.container);
                vec = _this.captured.point.subtract(pt0);
                new TranslateCommand(_this.captured.piece, vec).post();
                return;
              } else {
                _this.captured.point = new Point(e.clientX, e.clientY).fromWindow().to(_this.puzzle.container);
                pt = _this.captured.point.to(_this.captured.piece.shape);
                if (!_this.captured.piece.shape.hitTest(pt.x, pt.y)) {
                  _this.release();
                }
              }
            };
          })(this)
        });
      }
    };

    MouseController.prototype.release = function() {
      var p, ref;
      if (this.captured != null) {
        window.console.log("released[" + this.captured.piece.id + "]");
        p = this.captured.piece;
        p.shape.shadow = null;
        if (p.isAlive()) {
          ref = p.position(), p.shape.x = ref.x, p.shape.y = ref.y;
          p.shape.rotation = p.rotation();
          this.puzzle.container.addChild(p.shape);
        }
        this.captured = null;
        $(window).off('mousedown mouseup mousemove mousewheel');
        Command.commit();
        this.cacheStage(false);
        return this.puzzle.invalidate();
      }
    };

    MouseController.prototype.zoom = function(x, y, scale) {
      return this.puzzle.zoom(x, y, scale);
    };

    MouseController.prototype.cacheStage = function(b) {
      var h, pt0, pt1, ref, w;
      if (b == null) {
        b = true;
      }
      if (b) {
        ref = [window.screen.width, window.screen.height], w = ref[0], h = ref[1];
        pt0 = new Point(-w / 2, -h / 2).fromWindow().to(this.puzzle.wrapper);
        pt1 = new Point(w * 3 / 2, h * 3 / 2).fromWindow().to(this.puzzle.wrapper);
        this.puzzle.wrapper.cache(pt0.x, pt0.y, pt1.x - pt0.x, pt1.y - pt0.y);
      } else {
        this.puzzle.wrapper.uncache();
      }
    };

    MouseController.prototype.dragStage = function(event) {
      var last_point;
      this.cacheStage();
      last_point = new Point(event.clientX, event.clientY);
      return $(window).on({
        mousemove: (function(_this) {
          return function(e) {
            var pt;
            pt = new Point(e.clientX, e.clientY);
            _this.puzzle.wrapper.x += pt.x - last_point.x;
            _this.puzzle.wrapper.y += pt.y - last_point.y;
            last_point = pt;
            _this.puzzle.invalidate();
          };
        })(this),
        mouseup: (function(_this) {
          return function(e) {
            var pt;
            pt = new Point(0, 0).from(_this.puzzle.container).to(_this.puzzle.wrapper.parent);
            _this.puzzle.container.x = pt.x, _this.puzzle.container.y = pt.y;
            _this.puzzle.wrapper.x = 0;
            _this.puzzle.wrapper.y = 0;
            $(window).off('mousemove mouseup');
            _this.cacheStage(false);
            _this.puzzle.invalidate();
          };
        })(this)
      });
    };

    return MouseController;

  })();

  this.MouseController = MouseController;

}).call(this);
