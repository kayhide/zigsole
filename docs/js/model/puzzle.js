// Generated by CoffeeScript 1.12.7
(function() {
  var Puzzle;

  Puzzle = (function() {
    function Puzzle(canvas) {
      this.stage = new Stage(canvas);
      this.image = null;
      this.cutter = null;
      this.pieces = [];
      this.rotation_tolerance = 24;
      this.translation_tolerance = 0;
    }

    Puzzle.prototype.initizlize = function(image, cutter) {
      var i, j, len, p, ref;
      this.image = image;
      this.cutter = cutter;
      this.background = new Shape();
      this.background.color = "#002";
      this.background.alpha = 0.9;
      this.stage.addChild(this.background);
      this.pieces = this.cutter.cut(this.image);
      this.translation_tolerance = this.cutter.linear_measure / 8;
      this.wrapper = new Container();
      this.stage.addChild(this.wrapper);
      this.container = new Container();
      this.wrapper.addChild(this.container);
      ref = this.pieces;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        p = ref[i];
        p.id = i;
        p.puzzle = this;
        p.shape = new Shape();
        p.shape.piece = p;
        p.draw();
        this.container.addChild(p.shape);
      }
      this.foreground = new Container();
      this.stage.addChild(this.foreground);
      return Command.onPost.unshift((function(_this) {
        return function(cmd) {
          if (cmd instanceof MergeCommand) {
            _this.updateProgress();
          }
        };
      })(this));
    };

    Puzzle.prototype.updateProgress = function() {
      var i, p;
      i = ((function() {
        var j, len, ref, results;
        ref = this.pieces;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          p = ref[j];
          if (!p.isAlive()) {
            results.push(p);
          }
        }
        return results;
      }).call(this)).length;
      return this.progress = i / (this.cutter.count - 1);
    };

    Puzzle.prototype.tryMerge = function(piece) {
      var j, len, p, ref;
      ref = piece.getAdjacentPieces();
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (!(p.isWithinTolerance(piece))) {
          continue;
        }
        new MergeCommand(p, piece).commit();
        break;
      }
    };

    Puzzle.prototype.getBoundary = function() {
      var j, len, p, rect, ref;
      rect = Rectangle.createEmpty();
      ref = this.pieces;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (p.isAlive()) {
          rect.addRectangle(p.getBoundary());
        }
      }
      return rect;
    };

    Puzzle.prototype.shuffle = function() {
      var center, j, len, p, ref, results, s, vec;
      s = Math.max(this.image.width, this.image.height) * 2;
      ref = this.pieces;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (!(p.isAlive())) {
          continue;
        }
        center = p.getCenter();
        center = p.shape.localToParent(center.x, center.y);
        new RotateCommand(p, center, Math.random() * 360).post();
        vec = new Point(Math.random() * s, Math.random() * s);
        results.push(new TranslateCommand(p, vec.subtract(center)).post());
      }
      return results;
    };

    Puzzle.prototype.centerize = function() {
      var rect, ref, sx, sy;
      rect = this.getBoundary();
      ref = this.container, sx = ref.scaleX, sy = ref.scaleY;
      this.container.x = -rect.x * sx + (window.innerWidth - sx * rect.width) / 2;
      this.container.y = -rect.y * sy + (window.innerHeight - sy * rect.height) / 2;
      return this.stage.update();
    };

    Puzzle.prototype.fit = function() {
      var rect, sc, sx, sy;
      rect = this.getBoundary();
      sx = window.innerWidth / rect.width;
      sy = window.innerHeight / rect.height;
      sc = Math.min(sx, sy);
      this.container.scaleX = sc;
      this.container.scaleY = sc;
      this.container.x = -rect.x * sc + (window.innerWidth - sc * rect.width) / 2;
      this.container.y = -rect.y * sc + (window.innerHeight - sc * rect.height) / 2;
      return this.stage.update();
    };

    Puzzle.prototype.fill = function() {
      var rect, sc, sx, sy;
      rect = this.getBoundary();
      sx = window.innerWidth / rect.width;
      sy = window.innerHeight / rect.height;
      sc = Math.max(sx, sy);
      this.container.scaleX = sc;
      this.container.scaleY = sc;
      this.container.x = -rect.x * sc + (window.innerWidth - sc * rect.width) / 2;
      this.container.y = -rect.y * sc + (window.innerHeight - sc * rect.height) / 2;
      return this.stage.update();
    };

    Puzzle.prototype.zoom = function(x, y, scale) {
      var mtx, pt0, pt1;
      this.container.scaleX = this.container.scaleX * scale;
      this.container.scaleY = this.container.scaleX;
      pt0 = new Point(x, y).fromWindow().to(this.wrapper);
      mtx = new Matrix2D();
      mtx.translate(-pt0.x, -pt0.y);
      mtx.scale(scale, scale);
      mtx.translate(pt0.x, pt0.y);
      pt1 = this.container.position().apply(mtx);
      this.container.x = pt1.x, this.container.y = pt1.y;
      return this.stage.update();
    };

    Puzzle.prototype.invalidate = function() {
      return this.stage.invalidate();
    };

    return Puzzle;

  })();

  this.Puzzle = Puzzle;

}).call(this);
